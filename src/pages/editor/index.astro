---
import { getCollection } from "astro:content";
import PageLayout from "@layouts/PageLayout.astro";
import TopLayout from "@layouts/TopLayout.astro";
import BottomLayout from "@layouts/BottomLayout.astro";

// Check if we're editing an existing post
const editSlug = Astro.url.searchParams.get("edit");
let editPost = null;

if (editSlug) {
  console.log("=== EDITOR DEBUG ===");
  console.log("Looking for slug:", editSlug);

  try {
    const posts = await getCollection("blog");
    console.log("Total posts found:", posts.length);
    console.log(
      "Available post slugs:",
      posts.map((p) => `"${p.slug}"`)
    );

    editPost = posts.find((post) => post.slug === editSlug);
    console.log(
      "Found post:",
      editPost ? `YES - "${editPost.data.title}"` : "NO"
    );

    if (!editPost) {
      // Try exact match with different approaches
      const exactMatch = posts.find(
        (post) => post.slug.toString() === editSlug.toString()
      );
      console.log(
        "Exact string match:",
        exactMatch ? `YES - "${exactMatch.data.title}"` : "NO"
      );

      // Try case insensitive
      const caseInsensitive = posts.find(
        (post) => post.slug.toLowerCase() === editSlug.toLowerCase()
      );
      console.log(
        "Case insensitive match:",
        caseInsensitive ? `YES - "${caseInsensitive.data.title}"` : "NO"
      );

      editPost = exactMatch || caseInsensitive;
    }

    console.log(
      "Final editPost:",
      editPost ? `"${editPost.data.title}"` : "null"
    );

    // If post still not found, we'll handle it client-side
    // This allows for dev server delays in detecting new files
    if (!editPost) {
      console.log("Post not found in collection, will check client-side");
    }
  } catch (error) {
    console.error('ERROR in getCollection("blog"):', error);
    console.error("Error details:", error.message, error.stack);
    // Redirect on error as well
    return Astro.redirect("/editor");
  }

  console.log("===================");
}
---

<PageLayout title="Editor" description="Create and edit blog posts">
  <TopLayout>
    <div class="animate">
      <h1 class="text-3xl font-semibold text-black dark:text-white mt-2">
        {editPost ? `Edit: ${editPost.data.title}` : "Blog Editor"}
      </h1>
      <div class="mt-1">
        {editPost ? "Edit your blog post" : "Create and edit your blog posts"}
      </div>
    </div>
  </TopLayout>
  <BottomLayout>
    <div class="animate">
      <div id="editor-container" class="space-y-6 min-h-[600px]">
        <!-- Upload Section -->
        <!-- <div class="border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden">
          <div class="px-4 py-3 bg-gray-50 dark:bg-gray-800">
            <h3 class="font-medium text-black dark:text-white">Import Markdown File</h3>
            <p class="text-sm text-gray-600 dark:text-gray-400 mt-1">Upload an existing .md file to edit</p>
          </div>
          <div class="px-4 py-3">
            <div
              id="file-upload-area"
              class="border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-6 text-center hover:border-blue-400 dark:hover:border-blue-500 transition-colors duration-200 cursor-pointer"
            >
              <input
                type="file"
                id="markdown-file-input"
                accept=".md,.markdown"
                class="hidden"
              />
              <div id="upload-content">
                <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
                  <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                </svg>
                <p class="mt-2 text-sm text-gray-600 dark:text-gray-400">
                  <span class="font-medium text-blue-600 dark:text-blue-400 hover:text-blue-500">Click to upload</span> or drag and drop
                </p>
                <p class="text-xs text-gray-500 dark:text-gray-500">Markdown files (.md, .markdown)</p>
              </div>
            </div>
          </div>
        </div> -->

        <!-- Title Section -->
        <div>
          <label
            for="post-title"
            class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
            >Title</label
          >
          <input
            type="text"
            id="post-title"
            placeholder="Enter post title"
            class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 text-black dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
          />
        </div>

        <!-- Metadata Section (collapsible) -->
        <div
          class="border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden"
        >
          <button
            id="metadata-toggle"
            class="w-full px-4 py-3 text-left bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors duration-200"
          >
            <div class="flex justify-between items-center">
              <span class="font-medium text-black dark:text-white"
                >Post Metadata</span
              >
              <svg
                id="metadata-chevron"
                class="w-5 h-5 transform transition-transform duration-200"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M19 9l-7 7-7-7"></path>
              </svg>
            </div>
          </button>
          <div id="metadata-content" class="px-4 py-3 space-y-4 hidden">
            <div>
              <label
                for="post-summary"
                class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
                >Summary</label
              >
              <textarea
                id="post-summary"
                rows="2"
                placeholder="Brief description of the post"
                class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 text-black dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              ></textarea>
            </div>
            <div class="relative">
              <label
                for="post-tags"
                class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
                >Tags (space-separated)</label
              >
              <input
                type="text"
                id="post-tags"
                placeholder="Tutorial Astro JavaScript"
                autocomplete="off"
                class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-800 text-black dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              />
              <!-- Autocomplete dropdown -->
              <div
                id="tags-autocomplete"
                class="relative z-50 w-full bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-md shadow-lg max-h-48 overflow-y-auto hidden"
                style="top: 100%"
              >
                <!-- Autocomplete suggestions will be populated here -->
              </div>
            </div>
            <div class="flex items-center">
              <input
                type="checkbox"
                id="post-draft"
                class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
              />
              <label
                for="post-draft"
                class="ml-2 text-sm font-medium text-gray-700 dark:text-gray-300"
                >Save as draft</label
              >
            </div>
          </div>
        </div>

        <!-- Editor Tabs -->
        <div class="border-b border-gray-200 dark:border-gray-700">
          <nav class="-mb-px flex space-x-8">
            <button
              id="edit-tab"
              class="editor-tab active py-2 px-1 border-b-2 border-blue-500 font-medium text-sm text-blue-600 dark:text-blue-400"
            >
              Edit
            </button>
            <button
              id="preview-tab"
              class="editor-tab py-2 px-1 border-b-2 border-transparent font-medium text-sm text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-gray-400 dark:hover:text-gray-300"
            >
              Preview
            </button>
          </nav>
        </div>

        <!-- Editor Content -->
        <div id="editor-content" class="space-y-4">
          <!-- Markdown Editor -->
          <div>
            <textarea
              id="markdown-editor"
              rows="20"
              placeholder="Write your markdown here... (Drop images directly into this editor)"
              class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-t-md bg-white dark:bg-gray-800 text-black dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 font-mono text-sm"
            ></textarea>

            <!-- Markdown Toolbar -->
            <div
              class="border border-t-0 border-gray-300 dark:border-gray-600 rounded-b-md bg-gray-50 dark:bg-gray-800 p-2"
            >
              <div class="flex flex-wrap gap-1">
                <!-- Text Formatting -->
                <button
                  type="button"
                  class="markdown-btn px-2 py-1 text-xs bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors duration-200"
                  data-markdown="**bold**"
                  data-selection="bold"
                  title="Bold text"
                >
                  <strong>B</strong>
                </button>
                <button
                  type="button"
                  class="markdown-btn px-2 py-1 text-xs bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors duration-200"
                  data-markdown="*italic*"
                  data-selection="italic"
                  title="Italic text"
                >
                  <em>I</em>
                </button>
                <button
                  type="button"
                  class="markdown-btn px-2 py-1 text-xs bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors duration-200"
                  data-markdown="`code`"
                  data-selection="code"
                  title="Inline code"
                >
                  <code>&lt;/&gt;</code>
                </button>
                <button
                  type="button"
                  class="markdown-btn px-2 py-1 text-xs bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors duration-200"
                  data-markdown="~~strikethrough~~"
                  data-selection="strikethrough"
                  title="Strikethrough text"
                >
                  <s>S</s>
                </button>

                <!-- Separator -->
                <div class="border-l border-gray-300 dark:border-gray-600 mx-1">
                </div>

                <!-- Headers -->
                <button
                  type="button"
                  class="markdown-btn px-2 py-1 text-xs bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors duration-200"
                  data-markdown="# "
                  data-prefix="true"
                  title="Heading 1"
                >
                  H1
                </button>
                <button
                  type="button"
                  class="markdown-btn px-2 py-1 text-xs bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors duration-200"
                  data-markdown="## "
                  data-prefix="true"
                  title="Heading 2"
                >
                  H2
                </button>
                <button
                  type="button"
                  class="markdown-btn px-2 py-1 text-xs bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors duration-200"
                  data-markdown="### "
                  data-prefix="true"
                  title="Heading 3"
                >
                  H3
                </button>

                <!-- Separator -->
                <div class="border-l border-gray-300 dark:border-gray-600 mx-1">
                </div>

                <!-- Lists -->
                <button
                  type="button"
                  class="markdown-btn px-2 py-1 text-xs bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors duration-200"
                  data-markdown="- "
                  data-prefix="true"
                  title="Bullet list"
                >
                  • List
                </button>
                <button
                  type="button"
                  class="markdown-btn px-2 py-1 text-xs bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors duration-200"
                  data-markdown="1. "
                  data-prefix="true"
                  title="Numbered list"
                >
                  1. List
                </button>

                <!-- Separator -->
                <div class="border-l border-gray-300 dark:border-gray-600 mx-1">
                </div>

                <!-- Links and Images -->
                <button
                  type="button"
                  class="markdown-btn px-2 py-1 text-xs bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors duration-200"
                  data-markdown="[link text](url)"
                  data-selection="link text"
                  title="Insert link"
                >
                  🔗 Link
                </button>
                <button
                  type="button"
                  class="markdown-btn px-2 py-1 text-xs bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors duration-200"
                  data-markdown="![alt text](image.jpg)"
                  data-selection="alt text"
                  title="Insert image"
                >
                  🖼️ Image
                </button>

                <!-- Separator -->
                <div class="border-l border-gray-300 dark:border-gray-600 mx-1">
                </div>

                <!-- Other Elements -->
                <button
                  type="button"
                  class="markdown-btn px-2 py-1 text-xs bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors duration-200"
                  data-markdown="> "
                  data-prefix="true"
                  title="Blockquote"
                >
                  " Quote
                </button>
                <button
                  type="button"
                  class="markdown-btn px-2 py-1 text-xs bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors duration-200"
                  data-markdown="```\ncode block\n```"
                  data-selection="code block"
                  title="Code block"
                >
                  📄 Code
                </button>
                <button
                  type="button"
                  class="markdown-btn px-2 py-1 text-xs bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-100 dark:hover:bg-gray-600 transition-colors duration-200"
                  data-markdown="---"
                  data-prefix="true"
                  title="Horizontal rule"
                >
                  ⎯⎯⎯ HR
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Preview Content -->
        <div id="preview-content" class="hidden">
          <div class="prose prose-gray dark:prose-invert max-w-none">
            <div id="preview-html">
              <p class="text-gray-500 dark:text-gray-400 italic">
                Preview will appear here...
              </p>
            </div>
          </div>
        </div>

        <!-- Actions -->
        <div class="flex gap-4">
          <button
            id="save-post"
            class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition-colors duration-200"
          >
            Save Post
          </button>
          <button
            id="clear-editor"
            class="bg-gray-300 hover:bg-gray-400 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-700 dark:text-gray-200 font-medium py-2 px-4 rounded-md transition-colors duration-200"
          >
            Clear
          </button>
          <button
            id="delete-post"
            class="bg-red-600 hover:bg-red-700 text-white font-medium py-2 px-4 rounded-md transition-colors duration-200 hidden"
          >
            Delete Post
          </button>
        </div>

        <!-- Status Messages -->
        <div id="status-message" class="hidden p-4 rounded-md"></div>
      </div>
    </div>
  </BottomLayout>
</PageLayout>

<!-- Prism.js for syntax highlighting in preview -->
<link
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
  rel="stylesheet"
/>
<script is:inline>
  // Load Prism.js dynamically with sequential loading
  window.loadPrism = function () {
    if (window.Prism) return Promise.resolve();

    return new Promise((resolve) => {
      const scripts = [
        "https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js",
        "https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js",
        "https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js",
        "https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js",
        "https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js",
        "https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js",
        "https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js",
        "https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js",
      ];

      function loadScript(src) {
        return new Promise((scriptResolve) => {
          const script = document.createElement("script");
          script.src = src;
          script.onload = scriptResolve;
          script.onerror = () => {
            console.warn("Failed to load script:", src);
            scriptResolve(); // Continue even if one script fails
          };
          document.head.appendChild(script);
        });
      }

      // Load scripts sequentially, not in parallel
      async function loadSequentially() {
        for (const script of scripts) {
          await loadScript(script);
        }
        resolve();
      }

      loadSequentially().catch((error) => {
        console.warn("Failed to load Prism.js:", error);
        resolve(); // Continue without Prism
      });
    });
  };
</script>

<script is:inline define:vars={{ editPost, editSlug }}>
  if (editPost) {
    window.editPostData = editPost;
    console.log("Setting editPostData:", editPost);
  } else if (editSlug) {
    console.log("No post found for slug:", editSlug);
    window.failedEditSlug = editSlug;
  }
</script>

<script is:inline>
  // Editor functionality
  class BlogEditor {
    constructor() {
      this.initializeEditor();
      this.setupEventListeners();
      this.loadEditData();
    }

    initializeEditor() {
      this.metadataToggle = document.getElementById("metadata-toggle");
      this.metadataContent = document.getElementById("metadata-content");
      this.metadataChevron = document.getElementById("metadata-chevron");
      this.editTab = document.getElementById("edit-tab");
      this.previewTab = document.getElementById("preview-tab");
      this.editorContent = document.getElementById("editor-content");
      this.previewContent = document.getElementById("preview-content");
      this.markdownEditor = document.getElementById("markdown-editor");
      this.previewHtml = document.getElementById("preview-html");
      this.saveButton = document.getElementById("save-post");
      this.clearButton = document.getElementById("clear-editor");
      this.deleteButton = document.getElementById("delete-post");
      this.statusMessage = document.getElementById("status-message");
      this.tagsInput = document.getElementById("post-tags");
      this.tagsAutocomplete = document.getElementById("tags-autocomplete");
      this.fileUploadArea = document.getElementById("file-upload-area");
      this.markdownFileInput = document.getElementById("markdown-file-input");
      this.availableTags = [];

      // Undo/Redo system
      this.undoStack = [];
      this.redoStack = [];
      this.maxUndoSteps = 50;
      this.lastSavedContent = "";
      this.undoTimeoutId = null;
    }

    setupEventListeners() {
      // Metadata toggle
      this.metadataToggle.addEventListener("click", () =>
        this.toggleMetadata()
      );

      // Tab switching
      this.editTab.addEventListener("click", () => this.showEditor());
      this.previewTab.addEventListener("click", () => this.showPreview());

      // Drag and drop for markdown editor
      this.markdownEditor.addEventListener("dragover", (e) =>
        this.handleMarkdownDragOver(e)
      );
      this.markdownEditor.addEventListener("drop", (e) =>
        this.handleMarkdownDrop(e)
      );
      this.markdownEditor.addEventListener("dragenter", (e) =>
        this.handleMarkdownDragEnter(e)
      );
      this.markdownEditor.addEventListener("dragleave", (e) =>
        this.handleMarkdownDragLeave(e)
      );

      // Actions
      this.saveButton.addEventListener("click", () => this.savePost());
      this.clearButton.addEventListener("click", () => this.clearEditor());
      if (this.deleteButton) {
        this.deleteButton.addEventListener("click", () => this.deletePost());
      }

      // Auto-update preview and track changes for undo
      this.markdownEditor.addEventListener("input", () => {
        this.updatePreview();
        this.trackContentChange();
      });

      // Keyboard shortcuts for undo/redo
      this.markdownEditor.addEventListener("keydown", (e) =>
        this.handleKeyboardShortcuts(e)
      );

      // Tags autocomplete
      console.log("Setting up tags autocomplete event listeners...");
      this.tagsInput.addEventListener("input", (e) => this.handleTagsInput(e));
      this.tagsInput.addEventListener("keydown", (e) =>
        this.handleTagsKeydown(e)
      );
      this.tagsInput.addEventListener("blur", () => this.hideAutocomplete());
      console.log("Tags event listeners attached");

      // File upload listeners (only if elements exist)
      if (this.fileUploadArea && this.markdownFileInput) {
        this.fileUploadArea.addEventListener("click", () =>
          this.markdownFileInput.click()
        );
        this.fileUploadArea.addEventListener("dragover", (e) =>
          this.handleFileUploadDragOver(e)
        );
        this.fileUploadArea.addEventListener("drop", (e) =>
          this.handleFileUploadDrop(e)
        );
        this.fileUploadArea.addEventListener("dragenter", (e) =>
          this.handleFileUploadDragEnter(e)
        );
        this.fileUploadArea.addEventListener("dragleave", (e) =>
          this.handleFileUploadDragLeave(e)
        );
        this.markdownFileInput.addEventListener("change", (e) =>
          this.handleFileUpload(e)
        );
      }

      // Load available tags
      this.loadAvailableTags();

      // Setup markdown toolbar
      this.setupMarkdownToolbar();

      // Initialize undo state
      this.initializeUndoState();
    }

    async loadEditData() {
      // Also check URL for edit parameter as backup
      const urlParams = new URLSearchParams(window.location.search);
      const editSlug = urlParams.get("edit");

      // Store the edit slug for potential deletion
      this.currentEditSlug = editSlug;

      if (window.editPostData) {
        const post = window.editPostData;
        console.log("Loading edit data:", post); // Debug log
        this.populateEditor(post);

        // Show delete button only if we actually have a post to edit
        if (this.deleteButton) {
          this.deleteButton.classList.remove("hidden");
        }
      } else if (editSlug) {
        // Try to fetch the post data as the server might not have detected it yet
        console.log(
          "editPostData not found in window, attempting to fetch:",
          editSlug
        );

        // Try to fetch with retry logic
        let retries = 3;
        const tryFetch = async () => {
          try {
            await this.fetchPostData(editSlug);
            // If successful, show delete button
            if (this.deleteButton) {
              this.deleteButton.classList.remove("hidden");
            }
          } catch (error) {
            retries--;
            if (retries > 0) {
              console.log(
                `Fetch failed, retrying... (${retries} attempts left)`
              );
              setTimeout(tryFetch, 2000); // Wait 2 seconds before retry
            } else {
              // All retries failed, redirect
              this.showStatus(
                "Post not found. Redirecting to editor...",
                "error"
              );
              setTimeout(() => {
                window.location.href = "/editor";
              }, 1500);
            }
          }
        };

        tryFetch();
      }
    }

    populateEditor(post) {
      // Load metadata
      const titleEl = document.getElementById("post-title");
      const summaryEl = document.getElementById("post-summary");
      const tagsEl = document.getElementById("post-tags");
      const draftEl = document.getElementById("post-draft");

      if (titleEl) titleEl.value = post.data.title || "";
      if (summaryEl) summaryEl.value = post.data.summary || "";
      if (tagsEl) tagsEl.value = post.data.tags ? post.data.tags.join(" ") : "";
      if (draftEl) draftEl.checked = post.data.draft || false;

      // Load content (remove frontmatter if present)
      const content = post.body || "";
      if (this.markdownEditor) {
        this.markdownEditor.value = content;
      }

      // Update preview
      this.updatePreview();

      // Show metadata section by default when editing
      if (this.metadataContent) {
        this.metadataContent.classList.remove("hidden");
      }
      if (this.metadataChevron) {
        this.metadataChevron.style.transform = "rotate(180deg)";
      }

      this.showStatus("Loaded post for editing: " + post.data.title, "info");

      // Reinitialize undo state with loaded content
      this.initializeUndoState();
    }

    async fetchPostData(slug) {
      try {
        // Try to fetch the raw markdown file directly
        const response = await fetch(`/src/content/blog/${slug}.md`);
        if (response.ok) {
          const content = await response.text();
          const postData = this.parseMarkdownContent(content, slug);
          console.log("Parsed post data:", postData);
          this.populateEditor(postData);
          this.showStatus(`Loaded post: ${postData.data.title}`, "success");
        } else {
          throw new Error("Post file not found");
        }
      } catch (error) {
        this.showStatus(
          "Could not load post data. The post may not exist or server-side loading failed.",
          "error"
        );
        throw new Error("Could not fetch post data: " + error.message);
      }
    }

    parseMarkdownContent(content, slug) {
      // Parse frontmatter and content
      const frontmatterMatch = content.match(
        /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/
      );

      if (!frontmatterMatch) {
        throw new Error("Invalid frontmatter format");
      }

      const [, frontmatterText, body] = frontmatterMatch;

      // Simple YAML parsing for frontmatter
      const data = {};
      const lines = frontmatterText.split("\n");
      let currentKey = null;
      let arrayValues = [];

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;

        if (trimmed.startsWith("- ")) {
          // Array item
          if (currentKey) {
            arrayValues.push(trimmed.substring(2));
          }
        } else {
          // Key-value pair
          if (currentKey && arrayValues.length > 0) {
            data[currentKey] = arrayValues;
            arrayValues = [];
          }

          const colonIndex = trimmed.indexOf(":");
          if (colonIndex > -1) {
            currentKey = trimmed.substring(0, colonIndex).trim();
            let value = trimmed.substring(colonIndex + 1).trim();

            // Remove quotes and parse booleans
            if (value.startsWith('"') && value.endsWith('"')) {
              value = value.slice(1, -1);
            }
            if (value === "true") value = true;
            if (value === "false") value = false;

            data[currentKey] = value;
          }
        }
      }

      // Handle final array if exists
      if (currentKey && arrayValues.length > 0) {
        data[currentKey] = arrayValues;
      }

      return {
        slug,
        data,
        body: body.trim(),
      };
    }

    toggleMetadata() {
      const isHidden = this.metadataContent.classList.contains("hidden");
      if (isHidden) {
        this.metadataContent.classList.remove("hidden");
        this.metadataChevron.style.transform = "rotate(180deg)";
      } else {
        this.metadataContent.classList.add("hidden");
        this.metadataChevron.style.transform = "rotate(0deg)";
      }
    }

    showEditor() {
      this.editTab.classList.add("active", "border-blue-500", "text-blue-600");
      this.editTab.classList.remove("border-transparent", "text-gray-500");
      this.previewTab.classList.remove(
        "active",
        "border-blue-500",
        "text-blue-600"
      );
      this.previewTab.classList.add("border-transparent", "text-gray-500");

      this.editorContent.classList.remove("hidden");
      this.previewContent.classList.add("hidden");
    }

    showPreview() {
      this.previewTab.classList.add(
        "active",
        "border-blue-500",
        "text-blue-600"
      );
      this.previewTab.classList.remove("border-transparent", "text-gray-500");
      this.editTab.classList.remove(
        "active",
        "border-blue-500",
        "text-blue-600"
      );
      this.editTab.classList.add("border-transparent", "text-gray-500");

      this.editorContent.classList.add("hidden");
      this.previewContent.classList.remove("hidden");
      this.updatePreview();
    }

    async updatePreview() {
      const markdown = this.markdownEditor.value;
      if (markdown.trim()) {
        try {
          // Use Astro's markdown rendering pipeline via API
          const response = await fetch("/api/render-markdown", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ markdown }),
          });

          if (response.ok) {
            const result = await response.json();
            if (result.success) {
              this.previewHtml.innerHTML = result.html;

              // Highlight code blocks with Prism
              if (typeof window !== "undefined" && window.loadPrism) {
                window
                  .loadPrism()
                  .then(() => {
                    if (window.Prism) {
                      try {
                        setTimeout(() => {
                          window.Prism.highlightAll();
                        }, 10);
                      } catch (error) {
                        console.log("Prism highlighting failed:", error);
                      }
                    }
                  })
                  .catch((error) => {
                    console.log("Failed to load Prism:", error);
                  });
              }
            } else {
              throw new Error(result.error || "Failed to render markdown");
            }
          } else {
            throw new Error("Failed to render markdown");
          }
        } catch (error) {
          console.error("Preview rendering error:", error);
          this.previewHtml.innerHTML = `<p class="text-red-500">Error rendering preview: ${error.message}</p>`;
        }
      } else {
        this.previewHtml.innerHTML =
          '<p class="text-gray-500 dark:text-gray-400 italic">Preview will appear here...</p>';
      }
    }

    async uploadImage(file) {
      try {
        const formData = new FormData();
        formData.append("image", file);

        const response = await fetch("/api/upload-image", {
          method: "POST",
          body: formData,
        });

        if (!response.ok) {
          throw new Error("Failed to upload image");
        }

        const result = await response.json();
        if (result.success) {
          return result.path;
        } else {
          throw new Error(result.error || "Upload failed");
        }
      } catch (error) {
        console.error("Image upload error:", error);
        throw error;
      }
    }

    handleMarkdownDragEnter(event) {
      event.preventDefault();
      this.markdownEditor.classList.add("drag-over");
    }

    handleMarkdownDragLeave(event) {
      event.preventDefault();
      // Only remove drag-over if we're actually leaving the textarea
      if (!this.markdownEditor.contains(event.relatedTarget)) {
        this.markdownEditor.classList.remove("drag-over");
        // Clear any pending drag over timeout
        if (this.dragOverTimeout) {
          clearTimeout(this.dragOverTimeout);
          this.dragOverTimeout = null;
        }
      }
    }

    handleMarkdownDragOver(event) {
      event.preventDefault();
      event.dataTransfer.dropEffect = "copy";

      // Throttle cursor position updates to avoid excessive DOM manipulation
      if (!this.dragOverTimeout) {
        this.dragOverTimeout = setTimeout(() => {
          // Calculate drop position and update cursor to show where image will be inserted
          const dropPosition = this.getTextareaDropPosition(event);

          // Set cursor position to show where the image will be inserted
          this.markdownEditor.focus();
          this.markdownEditor.setSelectionRange(dropPosition, dropPosition);

          this.dragOverTimeout = null;
        }, 50); // Update every 50ms max
      }
    }

    async handleMarkdownDrop(event) {
      event.preventDefault();
      this.markdownEditor.classList.remove("drag-over");

      // Clear any pending drag over timeout
      if (this.dragOverTimeout) {
        clearTimeout(this.dragOverTimeout);
        this.dragOverTimeout = null;
      }

      const files = event.dataTransfer.files;
      if (files.length > 0) {
        // Get drop position for textarea
        const dropPosition = this.getTextareaDropPosition(event);
        console.log("Drop position calculated:", dropPosition);

        // Process files at the drop position
        await this.processFilesAtPosition(files, dropPosition);
      }
    }

    getTextareaDropPosition(event) {
      const textarea = this.markdownEditor;
      const rect = textarea.getBoundingClientRect();

      // Get relative mouse position
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      // Account for scroll position
      const scrollLeft = textarea.scrollLeft;
      const scrollTop = textarea.scrollTop;

      // Get textarea style for calculations
      const style = window.getComputedStyle(textarea);
      const paddingLeft = parseInt(style.paddingLeft);
      const paddingTop = parseInt(style.paddingTop);
      const lineHeight =
        parseInt(style.lineHeight) || parseInt(style.fontSize) * 1.2;

      // Calculate which line was clicked (accounting for padding and scroll)
      const clickedLine = Math.floor((y + scrollTop - paddingTop) / lineHeight);

      // Split content into lines
      const lines = textarea.value.split("\n");

      // Calculate position up to the clicked line
      let position = 0;
      for (let i = 0; i < Math.min(clickedLine, lines.length); i++) {
        position += lines[i].length + 1; // +1 for newline character
      }

      // If we clicked beyond the last line, position at end
      if (clickedLine >= lines.length) {
        return textarea.value.length;
      }

      // For the clicked line, estimate character position
      if (lines[clickedLine]) {
        // Create a temporary element to measure character width
        const tempElement = document.createElement("span");
        tempElement.style.font = style.font;
        tempElement.style.fontFamily = style.fontFamily;
        tempElement.style.fontSize = style.fontSize;
        tempElement.style.fontWeight = style.fontWeight;
        tempElement.style.visibility = "hidden";
        tempElement.style.position = "absolute";
        tempElement.textContent = "M"; // Use monospace character for measurement
        document.body.appendChild(tempElement);

        const charWidth = tempElement.offsetWidth;
        document.body.removeChild(tempElement);

        // Estimate character position within the line
        const lineClickX = x + scrollLeft - paddingLeft;
        const charPosition = Math.round(lineClickX / charWidth);

        // Clamp to line length
        const actualCharPosition = Math.min(
          Math.max(0, charPosition),
          lines[clickedLine].length
        );
        position += actualCharPosition;
      }

      // Clamp to textarea content length
      return Math.min(Math.max(0, position), textarea.value.length);
    }

    async processFilesAtPosition(files, position) {
      for (let file of files) {
        if (file.type.startsWith("image/")) {
          try {
            const imageUrl = await this.uploadImage(file);
            const markdownImage = `![${file.name}](${imageUrl})\n\n`;
            const currentContent = this.markdownEditor.value;
            const newContent =
              currentContent.slice(0, position) +
              markdownImage +
              currentContent.slice(position);
            this.markdownEditor.value = newContent;
            this.markdownEditor.focus();
            // Set cursor after the inserted image
            const newCursorPos = position + markdownImage.length;
            this.markdownEditor.setSelectionRange(newCursorPos, newCursorPos);
            // Update position for next file
            position = newCursorPos;
          } catch (error) {
            this.showStatus("Error uploading image: " + error.message, "error");
          }
        }
      }
    }

    // File upload handlers
    handleFileUploadDragEnter(event) {
      event.preventDefault();
      this.fileUploadArea.classList.add(
        "border-blue-400",
        "dark:border-blue-500",
        "bg-blue-50",
        "dark:bg-blue-900/20"
      );
    }

    handleFileUploadDragLeave(event) {
      event.preventDefault();
      if (!this.fileUploadArea.contains(event.relatedTarget)) {
        this.fileUploadArea.classList.remove(
          "border-blue-400",
          "dark:border-blue-500",
          "bg-blue-50",
          "dark:bg-blue-900/20"
        );
      }
    }

    handleFileUploadDragOver(event) {
      event.preventDefault();
      event.dataTransfer.dropEffect = "copy";
    }

    async handleFileUploadDrop(event) {
      event.preventDefault();
      this.fileUploadArea.classList.remove(
        "border-blue-400",
        "dark:border-blue-500",
        "bg-blue-50",
        "dark:bg-blue-900/20"
      );

      const files = event.dataTransfer.files;
      if (files.length > 0) {
        await this.processMarkdownFile(files[0]);
      }
    }

    async handleFileUpload(event) {
      const file = event.target.files[0];
      if (file) {
        await this.processMarkdownFile(file);
      }
    }

    async processMarkdownFile(file) {
      if (!file.name.endsWith(".md") && !file.name.endsWith(".markdown")) {
        this.showStatus(
          "Please select a markdown file (.md or .markdown)",
          "error"
        );
        return;
      }

      try {
        this.showStatus("Loading markdown file...", "info");

        const content = await file.text();
        const parsedData = this.parseMarkdownContent(
          content,
          file.name.replace(/\.(md|markdown)$/, "")
        );

        // Populate the editor with the loaded data
        this.populateEditor(parsedData);

        this.showStatus(`Loaded markdown file: ${file.name}`, "success");

        // Clear the file input for future uploads
        this.markdownFileInput.value = "";
      } catch (error) {
        console.error("Error processing markdown file:", error);
        this.showStatus(
          "Error reading markdown file: " + error.message,
          "error"
        );
      }
    }

    async savePost() {
      const title = document.getElementById("post-title").value.trim();
      const summary = document.getElementById("post-summary").value.trim();
      const tags = document.getElementById("post-tags").value.trim();
      const draft = document.getElementById("post-draft").checked;
      const content = this.markdownEditor.value.trim();

      if (!title || !content) {
        this.showStatus(
          "Please provide both a title and content for the post.",
          "error"
        );
        return;
      }

      try {
        this.showStatus("Saving post...", "info");

        // Send to save-post API
        const response = await fetch("/api/save-post", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            title,
            summary,
            tags: tags.split(" ").filter((tag) => tag.trim()),
            draft,
            content: "\n" + content, // Add newline after frontmatter
            editSlug: this.currentEditSlug, // Pass the edit slug if we're editing
          }),
        });

        const result = await response.json();

        if (response.ok && result.success) {
          const action = this.currentEditSlug ? "updated" : "saved";
          this.showStatus(
            `Post ${action} successfully as: ${result.filename}`,
            "success"
          );

          // Only offer to clear editor for new posts, not when editing
          if (!this.currentEditSlug) {
            if (
              confirm(
                "Post saved! Would you like to clear the editor to create a new post?"
              )
            ) {
              this.clearEditor();
            }
          }
        } else {
          throw new Error(result.error || "Failed to save post");
        }
      } catch (error) {
        console.error("Save error:", error);
        this.showStatus("Error saving post: " + error.message, "error");

        // Fallback: offer to download the file
        this.showStatus(
          "Saving to server failed. Creating downloadable file instead...",
          "info"
        );
        this.downloadPost(title, summary, tags, draft, content);
      }
    }

    downloadPost(title, summary, tags, draft, content) {
      // Create frontmatter for download
      const frontmatter = `---
title: "${title}"
summary: "${summary}"
date: "${new Date().toLocaleDateString("en-US", { year: "numeric", month: "short", day: "numeric" })}"
draft: ${draft}
tags:
${tags
  .split(" ")
  .filter((tag) => tag.trim())
  .map((tag) => `- ${tag.trim()}`)
  .join("\n")}
---

`;

      const fullContent = frontmatter + content;

      // Create a downloadable file
      const blob = new Blob([fullContent], { type: "text/markdown" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      const filename =
        title
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, "-")
          .replace(/^-|-$/g, "") + ".md";
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    clearEditor() {
      if (
        confirm(
          "Are you sure you want to clear all content? This cannot be undone."
        )
      ) {
        document.getElementById("post-title").value = "";
        document.getElementById("post-summary").value = "";
        document.getElementById("post-tags").value = "";
        document.getElementById("post-draft").checked = false;
        this.markdownEditor.value = "";
        this.updatePreview();
        this.showStatus("Editor cleared.", "info");

        // Reinitialize undo state after clearing
        this.initializeUndoState();
      }
    }

    async deletePost() {
      if (!this.currentEditSlug) {
        this.showStatus(
          "No post to delete. This only works when editing an existing post.",
          "error"
        );
        return;
      }

      const title =
        document.getElementById("post-title").value || this.currentEditSlug;

      if (
        confirm(
          `Are you sure you want to delete "${title}"? This cannot be undone.`
        )
      ) {
        try {
          this.showStatus("Deleting post...", "info");

          const response = await fetch("/api/delete-post", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              slug: this.currentEditSlug,
            }),
          });

          const result = await response.json();

          if (response.ok && result.success) {
            this.showStatus(
              "Post deleted successfully. Redirecting...",
              "success"
            );

            // Redirect to homepage after a short delay
            setTimeout(() => {
              window.location.href = "/";
            }, 1500);
          } else {
            throw new Error(result.error || "Failed to delete post");
          }
        } catch (error) {
          console.error("Delete error:", error);
          this.showStatus("Error deleting post: " + error.message, "error");
        }
      }
    }

    async loadAvailableTags() {
      try {
        console.log("Loading available tags...");
        const response = await fetch("/api/get-tags");
        console.log("Response status:", response.status);

        if (response.ok) {
          const data = await response.json();
          console.log("Raw API response:", data);
          this.availableTags = data.tags || [];
          console.log("Loaded tags array:", this.availableTags);
          console.log("Number of tags:", this.availableTags.length);
        } else {
          console.error(
            "API response not ok:",
            response.status,
            response.statusText
          );
          const errorText = await response.text();
          console.error("Error response body:", errorText);
          this.availableTags = [];
        }
      } catch (error) {
        console.error("Failed to load available tags:", error);
        this.availableTags = [];
      }
    }

    handleTagsInput(event) {
      const value = event.target.value;
      const cursorPos = event.target.selectionStart;

      // Find the current word being typed
      const beforeCursor = value.substring(0, cursorPos);
      const afterCursor = value.substring(cursorPos);
      const words = beforeCursor.split(" ");
      const currentWord = words[words.length - 1];

      // Debug logging removed for cleaner console

      // Show autocomplete for any non-empty word
      if (currentWord.length > 0 && currentWord.trim().length > 0) {
        this.showAutocomplete(currentWord, words.length - 1);
      } else {
        this.hideAutocomplete();
      }
    }

    handleTagsKeydown(event) {
      const autocomplete = this.tagsAutocomplete;
      const suggestions = autocomplete.querySelectorAll(".suggestion-item");
      const selected = autocomplete.querySelector(".suggestion-item.selected");

      if (
        !autocomplete.classList.contains("hidden") &&
        suggestions.length > 0
      ) {
        switch (event.key) {
          case "ArrowDown":
            event.preventDefault();
            if (selected) {
              selected.classList.remove("selected");
              const next = selected.nextElementSibling || suggestions[0];
              next.classList.add("selected");
            } else {
              suggestions[0].classList.add("selected");
            }
            break;

          case "ArrowUp":
            event.preventDefault();
            if (selected) {
              selected.classList.remove("selected");
              const prev =
                selected.previousElementSibling ||
                suggestions[suggestions.length - 1];
              prev.classList.add("selected");
            } else {
              suggestions[suggestions.length - 1].classList.add("selected");
            }
            break;

          case "Enter":
          case "Tab":
            event.preventDefault();
            if (selected) {
              this.selectTag(selected.textContent);
            }
            break;

          case "Escape":
            this.hideAutocomplete();
            break;
        }
      }
    }

    showAutocomplete(currentWord, wordIndex) {
      console.log(
        "Tag autocomplete for:",
        currentWord,
        "| Available tags:",
        this.availableTags.length
      );

      const currentWordLower = currentWord.toLowerCase().trim();
      const matches = this.availableTags.filter((tag) => {
        const tagLower = tag.toLowerCase();
        return (
          tagLower.startsWith(currentWordLower) && tagLower !== currentWordLower
        );
      });

      console.log("Matches found:", matches);

      if (matches.length === 0) {
        this.hideAutocomplete();
        return;
      }

      const autocomplete = this.tagsAutocomplete;
      autocomplete.innerHTML = "";

      matches.slice(0, 8).forEach((tag, index) => {
        const item = document.createElement("div");
        item.className =
          "suggestion-item px-3 py-2 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 text-sm";
        item.textContent = tag;

        item.addEventListener("mousedown", (e) => {
          e.preventDefault(); // Prevent blur from hiding autocomplete
          this.selectTag(tag);
        });

        autocomplete.appendChild(item);
      });

      autocomplete.classList.remove("hidden");
      this.currentWordIndex = wordIndex;
    }

    selectTag(tag) {
      const input = this.tagsInput;
      const value = input.value;
      const words = value.split(" ");

      // Replace the current word with the selected tag
      words[this.currentWordIndex] = tag;

      // Join back and add space if not at end
      const newValue = words.join(" ");
      input.value = newValue + (newValue.endsWith(" ") ? "" : " ");

      // Set cursor position after the inserted tag
      const cursorPos =
        words.slice(0, this.currentWordIndex + 1).join(" ").length + 1;
      input.setSelectionRange(cursorPos, cursorPos);

      this.hideAutocomplete();
      input.focus();
    }

    hideAutocomplete() {
      setTimeout(() => {
        this.tagsAutocomplete.classList.add("hidden");
      }, 150); // Small delay to allow click events
    }

    handleKeyboardShortcuts(event) {
      const isCtrl = event.ctrlKey || event.metaKey; // Support both Ctrl and Cmd on Mac

      if (isCtrl && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        this.undo();
      } else if (
        isCtrl &&
        (event.key === "y" || (event.key === "z" && event.shiftKey))
      ) {
        event.preventDefault();
        this.redo();
      }
    }

    trackContentChange() {
      // Debounce content changes to avoid too many undo steps
      if (this.undoTimeoutId) {
        clearTimeout(this.undoTimeoutId);
      }

      this.undoTimeoutId = setTimeout(() => {
        this.saveUndoState();
      }, 500); // Save undo state after 500ms of no typing
    }

    saveUndoState() {
      const currentContent = this.markdownEditor.value;
      const currentSelection = {
        start: this.markdownEditor.selectionStart,
        end: this.markdownEditor.selectionEnd,
      };

      // Don't save if content hasn't changed
      if (currentContent === this.lastSavedContent) {
        return;
      }

      // Save current state to undo stack
      this.undoStack.push({
        content: this.lastSavedContent,
        selection: this.lastSelection || { start: 0, end: 0 },
      });

      // Limit undo stack size
      if (this.undoStack.length > this.maxUndoSteps) {
        this.undoStack.shift();
      }

      // Clear redo stack when new changes are made
      this.redoStack = [];

      // Update last saved state
      this.lastSavedContent = currentContent;
      this.lastSelection = currentSelection;
    }

    undo() {
      if (this.undoStack.length === 0) {
        return;
      }

      // Save current state to redo stack
      this.redoStack.push({
        content: this.markdownEditor.value,
        selection: {
          start: this.markdownEditor.selectionStart,
          end: this.markdownEditor.selectionEnd,
        },
      });

      // Restore previous state
      const undoState = this.undoStack.pop();
      this.markdownEditor.value = undoState.content;
      this.markdownEditor.setSelectionRange(
        undoState.selection.start,
        undoState.selection.end
      );

      // Update tracking variables
      this.lastSavedContent = undoState.content;
      this.lastSelection = undoState.selection;

      // Update preview
      this.updatePreview();
    }

    redo() {
      if (this.redoStack.length === 0) {
        return;
      }

      // Save current state to undo stack
      this.undoStack.push({
        content: this.markdownEditor.value,
        selection: {
          start: this.markdownEditor.selectionStart,
          end: this.markdownEditor.selectionEnd,
        },
      });

      // Restore next state
      const redoState = this.redoStack.pop();
      this.markdownEditor.value = redoState.content;
      this.markdownEditor.setSelectionRange(
        redoState.selection.start,
        redoState.selection.end
      );

      // Update tracking variables
      this.lastSavedContent = redoState.content;
      this.lastSelection = redoState.selection;

      // Update preview
      this.updatePreview();
    }

    initializeUndoState() {
      // Initialize undo state with current content
      this.lastSavedContent = this.markdownEditor.value;
      this.lastSelection = {
        start: this.markdownEditor.selectionStart,
        end: this.markdownEditor.selectionEnd,
      };
    }

    setupMarkdownToolbar() {
      const markdownButtons = document.querySelectorAll(".markdown-btn");
      markdownButtons.forEach((button) => {
        button.addEventListener("click", (e) => {
          e.preventDefault();
          const markdown = button.dataset.markdown;
          const isPrefix = button.dataset.prefix === "true";
          const selectionText = button.dataset.selection;

          // Save undo state before making changes
          this.saveUndoState();
          this.insertMarkdown(markdown, isPrefix, selectionText);
        });
      });
    }

    insertMarkdown(markdownText, isPrefix = false, selectionText = null) {
      const textarea = this.markdownEditor;
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const selectedText = textarea.value.substring(start, end);
      const beforeText = textarea.value.substring(0, start);
      const afterText = textarea.value.substring(end);

      let insertText = markdownText;
      let newCursorPos = start;

      if (isPrefix) {
        // For prefixes like "# " or "- ", add to beginning of line
        const lineStart = beforeText.lastIndexOf("\n") + 1;
        const beforeLine = beforeText.substring(0, lineStart);
        const currentLine = beforeText.substring(lineStart);

        // Insert prefix at beginning of current line
        const newContent =
          beforeLine + markdownText + currentLine + selectedText + afterText;
        textarea.value = newContent;
        newCursorPos =
          lineStart +
          markdownText.length +
          currentLine.length +
          selectedText.length;
      } else if (selectionText && selectedText) {
        // Replace selected text with markdown wrapper
        if (markdownText.includes(selectionText)) {
          insertText = markdownText.replace(selectionText, selectedText);
        } else {
          insertText = markdownText;
        }
        const newContent = beforeText + insertText + afterText;
        textarea.value = newContent;
        newCursorPos = start + insertText.length;
      } else if (selectionText) {
        // Insert markdown with placeholder text selected
        const newContent = beforeText + markdownText + afterText;
        textarea.value = newContent;

        // Select the placeholder text
        const placeholderStart = start + markdownText.indexOf(selectionText);
        const placeholderEnd = placeholderStart + selectionText.length;
        textarea.focus();
        textarea.setSelectionRange(placeholderStart, placeholderEnd);
        this.updatePreview();
        return;
      } else {
        // Simple insertion
        const newContent = beforeText + markdownText + afterText;
        textarea.value = newContent;
        newCursorPos = start + markdownText.length;
      }

      // Set cursor position and update preview
      textarea.focus();
      textarea.setSelectionRange(newCursorPos, newCursorPos);
      this.updatePreview();
    }

    showStatus(message, type) {
      const colors = {
        success:
          "bg-green-50 dark:bg-green-900/20 text-green-800 dark:text-green-200 border-green-200 dark:border-green-800",
        error:
          "bg-red-50 dark:bg-red-900/20 text-red-800 dark:text-red-200 border-red-200 dark:border-red-800",
        info: "bg-blue-50 dark:bg-blue-900/20 text-blue-800 dark:text-blue-200 border-blue-200 dark:border-blue-800",
      };

      this.statusMessage.className = `p-4 rounded-md border ${colors[type]}`;
      this.statusMessage.textContent = message;
      this.statusMessage.classList.remove("hidden");

      setTimeout(() => {
        this.statusMessage.classList.add("hidden");
      }, 5000);
    }
  }

  // Initialize editor when page loads
  function initEditor() {
    console.log("Initializing BlogEditor...");
    console.log("editPostData available:", !!window.editPostData);
    console.log("failedEditSlug available:", !!window.failedEditSlug);
    if (window.editPostData) {
      console.log("editPostData:", window.editPostData);
    }
    if (window.failedEditSlug) {
      console.log("Failed to find post for slug:", window.failedEditSlug);
    }
    new BlogEditor();
  }

  // Initialize editor when page loads
  document.addEventListener("astro:page-load", initEditor);

  // Also initialize on initial page load
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initEditor);
  } else {
    // Wait a bit to ensure the editPostData script has run
    setTimeout(initEditor, 100);
  }
</script>

<style>
  .editor-tab.active {
    @apply border-blue-500 text-blue-600 dark:text-blue-400;
  }

  .editor-tab:not(.active) {
    @apply border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-gray-400 dark:hover:text-gray-300;
  }

  .suggestion-item.selected {
    @apply bg-blue-100 dark:bg-blue-800 text-blue-900 dark:text-blue-100;
  }

  #markdown-editor.drag-over {
    @apply border-blue-400 bg-blue-50 dark:bg-blue-900/20 border-2;
  }
</style>
